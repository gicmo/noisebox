#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from __future__ import print_function

import zmq
import json
import threading

from SocketServer import ThreadingMixIn
from BaseHTTPServer import HTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler
import signal
import struct
import time
import datetime


class RequestHandler(SimpleHTTPRequestHandler):

    def serve_file(self):
        SimpleHTTPRequestHandler.do_GET(self)

    def data(self):
        ipc = self.server.zmq_ctx.socket(zmq.REQ)
        ipc.connect("tcp://localhost:5557")
        now = time.time()
        delta = datetime.timedelta(weeks=-1)
        t_start = now + delta.total_seconds()
        ipc.send(struct.pack('III', 2, t_start, now))
        data = ipc.recv_json()

        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        response = json.dumps(data, sort_keys=True, indent=4, separators=(', ', ': '))
        self.send_header('Content-length', len(response))
        self.end_headers()
        self.wfile.write(str(response))

    def subscribe(self):
        zmq_ctx = self.server.zmq_ctx
        updates = zmq_ctx.socket(zmq.SUB)
        updates.connect("tcp://localhost:5556")
        updates.setsockopt_string(zmq.SUBSCRIBE, u'')

        hm = zmq_ctx.socket(zmq.SUB)
        hm.connect("inproc://hangman")
        hm.setsockopt_string(zmq.SUBSCRIBE, u'')

        self.send_response(200)
        self.send_header('Content-type', 'text/event-stream')
        self.end_headers()

        poller = zmq.Poller()
        poller.register(updates, zmq.POLLIN)
        poller.register(hm, zmq.POLLIN)

        while True:
            ready = dict(poller.poll())
            if hm in ready:
                break  # This is our stop signal

            if updates in ready:
                update = updates.recv()
                ut, _, _, val = struct.unpack('HHIf', update)

                known_ut = {
                    1: 'temperature',
                    2: 'humidity'
                }

                if ut not in known_ut:
                    continue

                js = json.dumps({known_ut[ut]: val})
                self.wfile.write('data: %s \n\n' % js)
                self.wfile.flush()

    def do_GET(self):
        if self.path == '/' or self.path == 'index.htm':
            self.serve_file()
        elif self.path.startswith('/css/') or self.path.startswith('/font/'):
            self.serve_file()
        elif self.path == '/data':
            self.data()
        elif self.path == '/subscribe':
            self.subscribe()
        else:
            self.send_response(404)
            self.send_header('Content-type', 'text/plain')
            response = "Not found :("
            self.send_header('Content-length', len(response))
            self.end_headers()
            self.wfile.write(response)


class ThreadingServer(ThreadingMixIn, HTTPServer):
    def __init__(self, server_address):
        HTTPServer.__init__(self, server_address, RequestHandler)
        context = zmq.Context()
        self.zmq_ctx = context

        hangman = context.socket(zmq.PUB)
        hangman.bind("inproc://hangman")
        self.hangman = hangman

    def stop(self):
        threading.Thread(target=self.shutdown).start()
        self.hangman.send(b"Stop")

if __name__ == "__main__":
    print("Noisebox monitor - HTTPd")
    print("Starting server")

    daemon = ThreadingServer(('', 8000))
    sig_handler = lambda s, a: daemon.stop()
    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)
    daemon.serve_forever()

